# Утверждения C/C++

Оператор утверждения задает условие, которое должно выполняться на определенном этапе работы программы. Если это условие не выполняется, утверждение признается ложным, выполнение программы прерывается и появляется диалоговое окно "Сбой утверждения".

# Как работают утверждения

Когда отладчик останавливается из-за утверждения MFC или библиотеки времени выполнения C, при наличии исходного кода отладчик перемещается к той точке в исходном файле, где сработало утверждение. Это сообщение утверждения появляется как в окне "Вывод", так и в диалоговом окне Сбой утверждения. Это сообщение можно скопировать из окна Вывод в текстовое окно, если нужно сохранить его для дальнейшего использования. В окне Вывод могут содержаться и другие сообщения об ошибках. Следует тщательно проверять эти сообщения, потому что они могут объяснить причину сбоя утверждения.

Используйте утверждения для обнаружения ошибок во время разработки. Как правило, следует использовать одно утверждение для каждого предположения. Например, если предполагается, что аргумент не равен NULL, используйте утверждение для проверки этого предположения.

# Утверждения в сборках отладки и выпуска

Операторы утверждений компилируются, только если определен _DEBUG. В противном случае компилятор рассматривает утверждения как операторы со значением NULL. Поэтому операторы утверждения не накладывают дополнительной нагрузки и не вызывают снижения производительности в итоговом выпуске программы и позволяют избежать использования директив #ifdef.

# Побочные эффекты использования утверждений

При добавлении утверждения в код следует убедиться, что это не вызовет побочных эффектов. Например, рассмотрим следующее утверждение, изменяющее значение nM.

    ASSERT(nM++ > 0); // Don't do this!

Поскольку выражение ASSERT не оценивается в окончательной версии программы, nM будет иметь различные значения в отладочной версии и в окончательной версии. Чтобы избежать этой проблемы в MFC, можно использовать макрос VERIFY вместо ASSERT. VERIFY оценивает выражение во всех версиях, но не проверяет результат в версии выпуска.

Следует быть особенно осторожным при вызовах функций в операторах утверждений, так как оценка функции может вызвать неожиданные побочные эффекты.

    ASSERT ( myFnctn(0)==1 ) // unsafe if myFnctn has side effects
    VERIFY ( myFnctn(0)==1 ) // safe

VERIFY вызывает myFnctn как в отладочной, так и в окончательной версии, поэтому им можно свободно пользоваться. Однако использование VERIFY в окончательной версии выпуска влечет дополнительную нагрузку в виде ненужного вызова функции.

# Утверждения CRT

Для проверки утверждения файл заголовка CRTDBG.H определяет макросы _ASSERT и _ASSERTE.

_ASSERT	    Если заданное выражение оценивается как FALSE, то результатом будет имя файла и номер строки _ASSERT.
_ASSERTE	Так же, как и _ASSERT, плюс строковое представление выражения, для которого было добавлено утверждение.

_ASSERTE более эффективен, так как он выводит выражение, принявшее значение FALSE. Этого действия может быть достаточно для распознавания проблемы без обращения к исходному коду. Однако отладочная версия приложения будет содержать строковую константу для каждого выражения, обрабатываемого _ASSERTE. При использовании нескольких макросов _ASSERTE эти строковые выражения могут требовать значительного количества памяти. Если это вызывает проблемы, то для экономии памяти используйте _ASSERT.

Если _DEBUG определен, макрос _ASSERTE определяется следующим образом:

    #define _ASSERTE(expr) \
        do { \
            if (!(expr) && (1 == _CrtDbgReport( \
                _CRT_ASSERT, __FILE__, __LINE__, #expr))) \
                _CrtDbgBreak(); \
        } while (0)

Если утверждаемое выражение оценивается как FALSE, для отчета о сбое утверждения вызывается функция _CrtDbgReport (использующая по умолчанию диалоговое окно сообщения). Если в диалоговом окне сообщения выбирается Повторить, _CrtDbgReport возвращает 1, а _CrtDbgBreak вызывает отладчик с помощью DebugBreak.

Если необходимо временно отключить все утверждения, используйте _CtrSetReportMode.

_CrtCheckMemory - проверка целостности кучи:

    _ASSERTE(_CrtCheckMemory());

_CrtIsValidPointer используется для проверки, допустима ли данная область памяти для записи или чтения:

    _ASSERTE(_CrtIsValidPointer( address, size, TRUE );

_CrtIsValidHeapPointer для проверки, указывает ли указатель на память в локальной куче (которая создается и управляется экземпляром библиотеки времени выполнения C — DLL-файл может иметь свой собственный экземпляр библиотеки и, таким образом, свою собственную кучу, вне кучи приложения). Это утверждение перехватывает не только пустые или выходящие за пределы области адреса, но и указатели на статические переменные, переменные стека и другую нелокальную память.

    _ASSERTE(_CrtIsValidPointer( myData );

_CrtIsMemoryBlock для проверки, находится ли блок памяти в локальной куче и является ли его тип допустимым:

    _ASSERTE(_CrtIsMemoryBlock (myData, size, &requestNumber, &filename, &linenumber));

Пример:

    #include <cassert>
    using namespace std;

    int UDiv(int x, int y) {
        assert(y != 0);
        assert(x > 0);
        assert(y > 0);
        if (y == 0)
            return 0;
        return x / y;
    }

    int main() {

        setlocale(LC_ALL, "ru-RU");

        UDiv(6, 2);
        UDiv(6, 0);
        UDiv(-6, 2);
        UDiv(6, -2);

    }

# Обработка исключений

Исключение — это условие ошибки, возможно вне элемента управления программы, которое не позволяет продолжать выполнение программы по обычному пути выполнения. Некоторые операции, включая создание объектов, входные и выходные данные файла и вызовы функций, выполняемые из других модулей, являются потенциальными источниками исключений, даже если программа работает правильно. В надежном коде можно предвидеть и обработать исключения. Чтобы обнаружить ошибки логики, используйте утверждения, а не исключения.

# Операторы try, throw и catch (C++)

Для реализации обработки исключений в C++ используются 

* try

* throw 

* catch .

Во-первых, используйте try блок, чтобы заключить одну или несколько инструкций, которые могут вызвать исключение.

throw выражение сигнализирует о том, что исключительное условие — часто случается, — в блоке произошла ошибка try . В качестве операнда выражения можно использовать объект любого типа throw . Обычно этот объект используется для передачи информации об ошибке. В большинстве случаев рекомендуется использовать класс std:: Exception или один из производных классов, определенных в стандартной библиотеке. Если один из них не подходит, рекомендуется создавать собственный класс исключения из std::exception .

Чтобы обрабатывать исключения, которые могут быть вызваны, реализуйте один или несколько catch блоков сразу после try блока. Каждый catch блок указывает тип исключения, которое может быть обработано.

В этом примере показан try блок и его обработчики. Предположим, GetNetworkResource() получает данные через сетевое подключение, а 2 типа исключений являются определенными пользователем классами, производными от std::exception. Обратите внимание, что исключения перехватываются по const ссылке в catch инструкции. Рекомендуется создавать исключения по значению и захватывать их ссылкой константы.

    MyData md;
    try {
    // Code that could throw an exception
    md = GetNetworkResource();
    }
    catch (const networkIOException& e) {
    // Code that executes when an exception of type
    // networkIOException is thrown in the try block
    // ...
    // Log error message in the exception object
    cerr << e.what();
    }
    catch (const myDataFormatException& e) {
    // Code that handles another exception type
    // ...
    cerr << e.what();
    }

    // The following syntax shows a throw expression
    MyData GetNetworkResource()
    {
    // ...
    if (IOSuccess == false)
        throw networkIOException("Unable to connect");
    // ...
    if (readError)
        throw myDataFormatException("Format error");
    // ...
    }

Код после try предложения является защищенным разделом кода. Это выражение throw—— исключение. Блок кода после catch предложения является обработчиком исключений. Это обработчик, который перехватывает исключение, возникающее, если типы в catch выражениях и совместимы. Список правил, регулирующих сопоставление типов в catch блоках, см. в разделе catch. Если catch оператор задает многоточие (...) вместо типа, catch блок обрабатывает каждый тип исключения. При компиляции с параметром /EHa они могут включать структурированные исключения C и созданные системой или асинхронные исключения, такие как защита памяти, деление на ноль и нарушения операций с плавающей запятой. Поскольку catch блоки обрабатываются в порядке программ для поиска соответствующего типа, обработчик многоточия должен быть последним обработчиком для связанного try блока. Используйте catch(...) осторожно, не позволяйте программе продолжать выполнение, если блоку catch не известно, как обработать конкретное перехваченное исключение. Как правило, блок catch(...) используется для ведения журнала ошибок и выполнения специальной очистки перед остановкой выполнения программы.

throw выражение, не имеющее операнда, повторно создает исключение, которое сейчас обрабатывается. Мы советуем использовать эту форму при повторном создании исключения, так как при этом сохраняются исходные ’ сведения об изменении типа данных. Такое выражение должно использоваться только в catch обработчике или в функции, которая вызывается из catch обработчика. Вновь созданный объект исключения представляет собой исходный объект исключения, а не его копию.

try {
   throw CSomeOtherException();
}
catch(...) {
   // Catch all exceptions - dangerous!!!
   // Respond (perhaps only partially) to the exception, then
   // re-throw to pass the exception to some other handler
   // ...
   throw;
}

# Правила работы catch

Если созданное исключение имеет тип класса, у которого имеется один или несколько базовых классов, то его могут перехватывать обработчики, которые принимают базовые классы (и ссылки на базовые классы) этого типа исключения. Обратите внимание, что если исключение перехватывается по ссылке, то оно привязывается к самому объекту исключения; в противном случае обрабатывается его копия (как и в случае с аргументами функции).

При возникновении исключения его могут перехватывать следующие типы обработчиков catch :

* Обработчик, который может принимать любой тип данных (синтаксис с многоточием).

* Обработчик, принимаюющий тот же тип, что и объект исключения; поскольку это копия, const и volatile модификаторы игнорируются.

* Обработчик, который принимает ссылку на тот же тип, что и у объекта исключения.

* Обработчик, принимаюющий ссылку на constvolatile или форму того же типа, что и объект исключения.

* Обработчик, принимаюющий базовый класс того же типа, что и объект исключения; так как это копия, const и volatile модификаторы игнорируются. Обработчик catch базового класса не должен предшествовать catch обработчику для производного класса.

* Обработчик, который принимает ссылку на базовый класс того же типа, что и у объекта исключения.

* Обработчик, принимаюющий ссылку на const базовый класс того же типа, volatile что и объект исключения.

* Обработчик, который принимает указатель, в который можно преобразовать созданный объект указателя при помощи стандартных правил преобразования указателей.

Порядок catch отображения обработчиков является значительным, так как обработчики для заданного try блока проверяются в порядке их внешнего вида. Например, ошибкой будет поместить обработчик для базового класса перед обработчиком для производного класса. После поиска соответствующего catch обработчика последующие обработчики не проверяются. В результате обработчик с многоточием catch должен быть последним обработчиком для своего try блока. Пример:

    // ...
    try
    {
        // ...
    }
    catch( ... )
    {
        // Handle exception here.
    }
    // Error: the next two handlers are never examined.
    catch( const char * str )
    {
        cout << "Caught exception: " << str << endl;
    }
    catch( CExcptClass E )
    {
        // Handle CExcptClass exception here.
    }

В этом примере обработчик многоточия catch является единственным проверяющим обработчиком.

# Класс exception

Этот класс служит базовым классом для всех исключений, создаваемых определенными выражениями и стандартной библиотекой C++.

    class exception {
    public:
    exception();
    exception(const char* const &message);
    exception(const char* const &message, int);
    exception(const exception &right);
    exception& operator=(const exception &right);
    virtual ~exception();
    virtual const char *what() const;
    };

В частности, этот базовый класс является корнем стандартных классов исключений, определенных в <stdexcept>. Значение строки в C, возвращаемое объектом what, не указывается конструктором по умолчанию, но может быть определено конструкторами для некоторых производных классов как строка C для заданной реализации. Ни одна из функций-членов не создает исключение.

Параметр int позволяет указать, что память не должна выделяться. Значение параметра int игнорируется.

# Необработанные исключения C++

Если соответствующий обработчик (или обработчик многоточия catch ) не найден для текущего исключения, вызывается предопределенная terminate функция времени выполнения. (Вы также можете явно вызвать terminate любой из обработчиков.) Действие terminate по умолчанию — вызов abort. Если вам необходимо, чтобы перед выходом из приложения функция terminate в вашей программе вызывала какую-то другую функцию, вызовите функцию set_terminate, указав в качестве ее единственного аргумента ту функцию, которую нужно вызвать. Функцию set_terminate можно вызвать из любого места программы. Подпрограмма terminate всегда вызывает последнюю функцию, заданную в качестве аргумента set_terminate.

В следующем примере создается исключение типа char *, однако в нем нет обработчика, предназначенного для перехвата исключений char *. Вызов set_terminate содержит инструкцию, согласно которой terminate вызывает функцию term_func.

    // exceptions_Unhandled_Exceptions.cpp
    // compile with: /EHsc
    #include <iostream>
    using namespace std;
    void term_func() {
    cout << "term_func was called by terminate." << endl;
    exit( -1 );
    }
    int main() {
    try
    {
        set_terminate( term_func );
        throw "Out of memory!"; // No catch handler for this exception
    }
    catch( int )
    {
        cout << "Integer exception raised." << endl;
    }
    return 0;
    }

Выходные данные

    term_func was called by terminate.

Функция term_func должна завершать программу или текущий поток (желательно путем вызова функции exit). Если вместо этого она 
возвращает управление вызвавшему объекту, то вызывается функция abort.

# Современные рекомендации по C++ для исключений и обработки ошибок

В современных C++ в большинстве случаев предпочтительным способом сообщить и обрабатывались как логические ошибки, так и ошибки времени выполнения — использовать исключения. Особенно это касается того, что стек может содержать несколько вызовов функций между функцией, которая обнаруживает ошибку, и функцией, которая имеет контекст для ее устранения. Исключения предоставляют формальный, четко определенный способ для кода, который обнаруживает ошибки для передачи информации вверх по стеку вызовов.

# Использовать исключения для кода исключительного пользования

Ошибки программы часто делятся на две категории: логические ошибки, вызванные ошибками программирования, например, ошибкой «индекс вне диапазона». И ошибки времени выполнения, которые выходят за рамки управления программистом, например "ошибка "Сетевая служба недоступна ". В программировании в стиле C и в COM Управление отчетами об ошибках осуществляется либо путем возвращения значения, представляющего код ошибки, либо кода состояния для конкретной функции, либо путем установки глобальной переменной, которую вызывающий может дополнительно получить после каждого вызова функции, чтобы проверить, были ли обнаружены ошибки. Например, при программировании COM для передачи ошибок вызывающему объекту используется возвращаемое значение HRESULT. API-интерфейс Win32 содержит GetLastError функцию для получения последней ошибки, о которой сообщил стек вызовов. В обоих случаях для распознавания кода и реагирования на него требуется вызывающая сторона. Если вызывающий объект не обрабатывает код ошибки явным образом, программа может аварийно завершить работу без предупреждения. Или можно продолжить выполнение с использованием неверных данных и получить неверные результаты.

Исключения являются предпочтительными в современных C++ по следующим причинам:

* Исключение приводит к тому, что вызывающий код распознает состояние ошибки и обрабатывает его. Необработанные исключения останавливают выполнение программы.

* Исключение переходит к точке в стеке вызовов, которая может справиться с ошибкой. Промежуточные функции могут позволить распространить исключение. Они не должны координироваться с другими уровнями.

* Механизм обратной записи исключений уничтожает все объекты в области действия после возникновения исключения в соответствии с четко определенными правилами.

* Исключение позволяет четко отделить код, который определяет ошибку, и код, обрабатывающий ошибку.

В следующем упрощенном примере показан синтаксис, необходимый для генерации и перехвата исключений в C++.

    #include <stdexcept>
    #include <limits>
    #include <iostream>

    using namespace std;

    void MyFunc(int c)
    {
        if (c > numeric_limits< char> ::max())
            throw invalid_argument("MyFunc argument too large.");
        //...
    }

    int main()
    {
        try
        {
            MyFunc(256); //cause an exception to throw
        }

        catch (invalid_argument& e)
        {
            cerr << e.what() << endl;
            return -1;
        }
        //...
        return 0;
    }

Исключения в C++ похожи на такие языки, как C# и Java. 
В блоке try при возникновении исключения оно будетперехвачено первым связанным catch блоком, тип которого совпадает с типом исключения. Иными словами, выполнение переходит от throw оператора к catch оператору. Если подходящий блок catch не найден, std::terminate вызывается метод и программа завершает работу. В C++ может быть вызван любой тип. Однако рекомендуется создавать тип, прямо или косвенно производный от std::exception . В предыдущем примере тип invalid_argument исключения определен в стандартной библиотеке в <stdexcept> файле заголовка. 

C++ не предоставляет или не требует finally блока, чтобы гарантировать освобождение всех ресурсов при возникновении исключения. Идиома получения ресурсов — инициализация (RAII), которая использует интеллектуальные указатели, предоставляет необходимые функции для очистки ресурсов. Дополнительные сведения см. в разделе руководство. проектирование безопасности исключений. 

# Основные рекомендации

Надежная обработка ошибок является сложной задачей в любом языке программирования. Хотя исключения предоставляют несколько функций, которые поддерживают хорошую обработку ошибок, они не могут выполнить всю работу. Чтобы реализовать преимущества механизма исключения, помните об исключениях при проектировании кода.

* Используйте утверждения, чтобы проверить наличие ошибок, которые не должны возникать. Используйте исключения для проверки ошибок, которые могут возникать, например, ошибок при проверке входных данных для параметров открытых функций. Дополнительные сведения см. в разделе исключения и утверждения .

* Используйте исключения, если код, обрабатывающий ошибку, отделен от кода, который обнаруживает ошибку одним или несколькими промежуточными вызовами функций. Рассмотрите возможность использования кодов ошибок в циклах, критических для производительности, когда код, обрабатывающий ошибку, тесно связан с кодом, который его обнаруживает.

* Для каждой функции, которая может выдавать или распространять исключение, следует предоставить одно из трех гарантий исключений: строгая гарантия, Базовая гарантия или "Throw" (Except). Дополнительные сведения см. в разделе руководство. проектирование безопасности исключений.

* Вызывайте исключения по значению, перехватите их по ссылке. Не перехватывайте объекты, которые не могут быть обработаны.

* Не используйте спецификации исключений, которые являются устаревшими в C++ 11. Дополнительные сведения см. в разделе спецификации исключений и noexcept раздел.

* Используйте типы исключений стандартной библиотеки при их применении. Наследовать пользовательские типы исключений от exception иерархии классов .

* Не разрешать исключения для экранирования из деструкторов или функций освобождения памяти.

# Исключения и производительность

Механизм исключения имеет минимальные затраты на производительность, если исключение не создается. При возникновении исключения стоимость прохода стека и его очистки приблизительно сравнима с затратами на вызов функции. Дополнительные структуры данных необходимы для контроля стека вызовов после того, как try был выполнен блок, и при возникновении исключения требуются дополнительные инструкции для очистки стека. Однако в большинстве случаев затраты на производительность и объем памяти не являются существенными. Негативное воздействие исключений на производительность может быть значительным только для систем с ограниченным объемом памяти. Кроме того, в циклах, критических с точки зрения производительности, часто возникает ошибка, и существует тесная связь между кодом и его обработкой. В любом случае невозможно понять фактическую стоимость исключений без профилирования и измерения. Даже в редких случаях, когда стоимость существенна, можно взвесить ее на более высокую правильность, упростить обслуживание и другие преимущества, предоставляемые хорошо спроектированной политикой исключений.

# Исключения и утверждения

Исключения и утверждения — это два отдельных механизма для обнаружения ошибок во время выполнения в программе. Используйте assert инструкции для проверки условий во время разработки, которые никогда не должны быть истинными, если весь код правильный. Нет никакой точки в обработке такой ошибки с помощью исключения, так как эта ошибка указывает на то, что что-то в коде должно быть исправлено. Он не представляет условие, которое программа может восстанавливать из среды выполнения. 

assert останавливает выполнение на инструкции, чтобы можно было проверить состояние программы в отладчике. Исключение продолжит выполнение из первого соответствующего обработчика catch. Используйте исключения для проверки ошибок, которые могут возникнуть во время выполнения, даже если код правильный, например "файл не найден" или "недостаточно памяти". Исключения могут обработаны, даже если восстановление просто выводит сообщение в журнал и завершает программу. Всегда проверяйте аргументы для открытых функций с помощью исключений. Даже если функция бесплатна, вы можете не иметь полного контроля над аргументами, которые пользователь может передать ему.


# Примеры

https://docs.microsoft.com/en-us/troubleshoot/developer/visualstudio/cpp/language-compilers/catch-exceptions

https://docs.microsoft.com/en-us/troubleshoot/developer/visualstudio/cpp/language-compilers/write-entry-to-event-log


